CREATE TABLE project
(
    id      uuid primary key,
    project text NOT NULL
);

INSERT INTO project (id, project)
VALUES ('00000000-0000-0000-0000-000000000001', 'Project 1'),
       ('00000000-0000-0000-0000-000000000002', 'Project 2');

-- TODO: Remove ON DELETE CASCADE and change to soft delete
CREATE TABLE estimate
(
    id         uuid primary key,
    project_id uuid NOT NULL REFERENCES project (id) ON UPDATE CASCADE ON DELETE CASCADE,
    estimate   text NOT NULL,
    cost       int  NOT NULL
);

INSERT INTO estimate (id, project_id, estimate, cost)
VALUES ('00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-000000000001', 'Estimate 1', 100),
       ('00000000-0000-0000-0000-000000000002', '00000000-0000-0000-0000-000000000001', 'Estimate 2', 200),
       ('00000000-0000-0000-0000-000000000003', '00000000-0000-0000-0000-000000000002', 'Estimate 3', 300);

CREATE TABLE assembly
(
    id       uuid primary key,
    assembly text NOT NULL
);

INSERT INTO assembly (id, assembly)
VALUES ('00000000-0000-0000-0000-000000000001', 'Assembly 1'),
       ('00000000-0000-0000-0000-000000000002', 'Assembly 2'),
       ('00000000-0000-0000-0000-000000000003', 'Assembly 3');

CREATE TABLE estimate_assemblies
(
    estimate_id uuid REFERENCES estimate (id) ON UPDATE CASCADE ON DELETE CASCADE,
    assembly_id uuid REFERENCES assembly (id) ON UPDATE CASCADE,
    quantity    int NOT NULL,
    PRIMARY KEY (estimate_id, assembly_id)
);

INSERT INTO estimate_assemblies (estimate_id, assembly_id, quantity)
VALUES ('00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-000000000001', 10),
       ('00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-000000000002', 20),
       ('00000000-0000-0000-0000-000000000002', '00000000-0000-0000-0000-000000000001', 30);


-- https://dba.stackexchange.com/questions/146906/insert-into-three-tables-with-many-to-many-from-one-table?
-- http://sqlfiddle.com/#!17/390a7/77
-- http://sqlfiddle.com/#!17/390a7/18

-- explain analyze

-- SELECT a.id, a.title, a.score
--      , ARRAY (
--         SELECT t.name
--         FROM   article_tag a_t
--                    JOIN   tag t ON t.id = a_t.tag_id
--         WHERE  a_t.article_id = a.id
--     -- ORDER  BY t.id  -- optionally sort array elements
--     ) AS names
-- FROM   article a
-- ORDER  BY a.score DESC
-- LIMIT  10;

--
-- CREATE TABLE assembly
-- (
--     id       int primary key GENERATED BY DEFAULT AS IDENTITY,
--     assembly text NOT NULL
-- );
--
-- CREATE TABLE estimate_assembly
-- (
--     estimate_id int REFERENCES estimates (id) ON UPDATE CASCADE ON DELETE CASCADE,
--     assembly_id int REFERENCES assemblies (id) ON UPDATE CASCADE,
--     quantity    int NOT NULL,
--     PRIMARY KEY (estimate_id, assembly_id)
-- );
--
-- INSERT INTO estimate (id, estimate)
-- VALUES (1, 'Estimate 1'),
--        (2, 'Estimate 2'),
--        (3, 'Estimate 3'),
--        (4, 'Estimate 4'),
--        (5, 'Estimate 5');
--
-- INSERT INTO assembly (id, assembly)
-- VALUES (1, 'Assembly 1'),
--        (2, 'Assembly 2'),
--        (3, 'Assembly 3'),
--        (4, 'Assembly 4');
--
-- INSERT INTO estimate_assembly (estimate_id, assembly_id, quantity)
-- VALUES (1, 1, 100),
--        (1, 2, 200),
--        (1, 3, 300),
--        (2, 4, 400);
--
-- CREATE TABLE project_estimates
-- (
--     project_id  int REFERENCES projects (id) ON UPDATE CASCADE,
--     estimate_id int REFERENCES estimates (id) ON UPDATE CASCADE ON DELETE CASCADE
-- );
--
-- INSERT INTO project_estimates (project_id, estimate_id)
-- VALUES (1, 1),
--        (1, 2),
--        (2, 3),
--        (2, 4),
--        (2, 5);
